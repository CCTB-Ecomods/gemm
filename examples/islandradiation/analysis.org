* Analyses scripts for island diversification experiments

** prepare data files

*** filter compatibility sequences
    two methods of sorting sequences according to header information: awk and sed
    sed feels faster

 #+BEGIN_SRC sh 
 ## awk "/compat/{print;getline;print}" 2019-07-02_islsimconfig_7/seqs_s7.fa > 2019-07-02_islsimconfig_7/compats.fa
 for i in ../../2019-12-06_islsim_*/seqs_s[0-9].fa ; do sed -n "/compat/{N;p}" $i > ${i%.fa}_compats.fa done
							
 for i in ../../2019-10-29_islsim_*/seqs_s[0-9][0-9].fa ; do sed -n "/compat/{N;p}" $i > ${i%.fa}_compats.fa done
#+END_SRC

 #+RESULTS:

 make sequences unique

#+BEGIN_SRC sh
 for i in ../../2019-06-28_islsim_*/*compats.fa ; do
     sed -e '/^>/s/$/@/' -e 's/^>/#/' $i |\
	 tr -d '\n' | tr "#" "\n" | tr "@" "\t" |\
	 sort -u -f -k 2  |\
	 sed -e 's/^/>/' -e 's/\t/\n/' |\
	 grep -Ev '^\s*$|^>\s*$' > ${i%compats.fa}uniq.fa
 done
 #+END_SRC

** R analyses
*** Packages

We use an anaconda environment that provides most of the packages.
Using environments alleviates common dependency issues.

Some packages are not supplied by anaconda though and we need to install them in our R environment:

 #+BEGIN_SRC R
   install.packages("dispRity")
   install.packages("paleotree")
   install.packages("lmerTest") # TODO: try including this in conda environment!
 #+END_SRC

 #+RESULTS:

Note that trying to install some of the above packages' dependencies via conda leads to conflicts, while it works directly in R.

Now, we can load the packages.

#+BEGIN_SRC R
 library(picante) ## provides both library(vegan) and library(ape) ade4?
 ## library(corrplot)
 library(cowplot) # arrange ggplots in a grid
 ## library(cluster)
 ## library(fpc) # additional cluster analysis functionalities
 library(factoextra) # additional ordination visualisation
 library(FactoMineR) # additional ordination methods
 library(dispRity) # calculates various measures of disparity of e.g. species w/ multivariate trait data CAVEAT: conflicts with paleotree
## library(matrixStats) # rowSds etc.
## library(geometry) # for convex hulls etc.
 library(paleotree)
 library(foreach)
 library(doParallel)
 library(tidyverse)
 library(lme4)
 library(lmerTest)
 theme_set(theme_classic()) ## or theme_linedraw?
#+END_SRC
*** set up parallel computing
#+BEGIN_SRC R
max_cores <- detectCores() - 1
registerDoParallel(16)
#+END_SRC

*** Custom functions

#+BEGIN_SRC R
read_indfiles = function(path = "", pattern = "", suffix = "") {
    indfiles = Sys.glob(paste0(path, pattern, suffix))
    rawinds = tibble()
    for (filepath in indfiles) {
      inds = read_tsv(filepath)
      inds$replicate = as.numeric(strsplit(strsplit(filepath, ".tsv")[[1]], "_s")[[1]][2])
      rawinds = bind_rows(rawinds, inds)
    }
    rawinds$lineageid = paste(rawinds$lineage, rawinds$id, sep="_")
    rawinds %>% select(-starts_with("X")) # most likely empty columns due to superfluous separators
}

read_seqfiles = function(path = "", pattern = "", suffix = "") { ## path, pattern and suffix might be combined
  seqfiles = Sys.glob(paste0(path, pattern, suffix))
  seqs = foreach (filepath = seqfiles, .combine = rbind) %dopar% {
    ## if (which(seqfiles == filepath) == 1) {
    ##       seqs = read.dna(file = filepath, format="fasta")
    ##   } else {
    newseq = read.dna(file=filepath, format="fasta")
    ##         if (length(newseq[1, ]) >= 100) seqs = rbind(seqs, newseq)
    ## }
  }
  seqs
}

reducetips = function(seqs, ntips = 10000){ #this reduces tips to a maximum of 10000 to prevent the vector allocation error
    if(length(seqs[,1]) > ntips){                                                                                                                                                  
        inds = sample(1:length(seqs[,1]), ntips)                                                                                                                                   
        seqs = seqs[inds,]
    }
    seqs
}

gettree = function(linseqs){
  if (length(linseqs[,1]) > 1) {
    linseqs = reducetips(linseqs)
    dists = dist.dna(linseqs, model = "raw") # raw better fitting than either F81 or JC69
    tre = hclust(dists, method = "ward.D2")
    tre$height <- round(tre$height, 6) # work-around 'height' component of 'tree' is not sorted (increasingly) error
    tre
  } else {
    NULL
  }
}

inferspecies = function(tre, spboundary){
  if (!is.null(tre)) {
    grps = cutree(tre, h = spboundary) # which height? constant (e.g. 2 base pairs difference) or species-specific?
    ## medreptol = rawinds %>% filter(lineage==lineage) %>% select(reptol) %>% as_vector %>% median
    ## how to decide what tips to drop when spanning large time scales?
    grps
  } else {
    tre
  }
}  

mksptree = function(tre, grps){
  if (!is.null(tre)) {
    species = drop.tip(as.phylo(tre), names(grps[duplicated(grps)]))
    species
  } else {
    tre
  }
}  

mkphylos = function(allseqs, rawinds, minimumtips = 3, spboundary = 0.05){
  seqlins = strsplit(dimnames(allseqs)[[1]], "_") %>% lapply(function(x) x[1]) %>% unlist #%>% unique %>% gsub(">", "", .)
  colids = rawinds %>% filter(time == 0) %>% select(lineageid) %>% unlist
  founderlins = rawinds %>% filter(!(lineageid %in% colids)) %>% select(lineage) %>% unique %>% unlist
  allphylos = foreach(lineage = unique(seqlins[seqlins %in% founderlins])) %dopar% {
    linseqs = allseqs[seqlins == lineage,]
    dimnames(linseqs)[[1]] = strsplit(dimnames(linseqs)[[1]], "_") %>% lapply(function(x) paste(x[1], x[2], sep = "_")) %>% unlist
    linseqs = linseqs[!duplicated(dimnames(linseqs)[[1]]),]
    if (length(linseqs[,1]) >= minimumtips) {
      if (spboundary == "actual") {
        spboundary = rawinds %>% filter(time == 0, lineage == !!lineage) %>%
          select(reptol) %>% min ## colonizing mainland individual able to reintegrate into island population
        spboundary = 1 - spboundary
      }
      tre = gettree(linseqs)
      grps = inferspecies(tre, spboundary)
      species = mksptree(tre, grps)
      times = rawinds %>% filter(lineage==!!lineage, time != 0) %>% select(time, lineageid) %>%
        inner_join(tibble(lineageid = names(grps), grps = grps), by = "lineageid") %>% 
        group_by(grps) %>% summarize(FAD=min(time), LAD=max(time)) %>%
        inner_join(tibble(lineageid = names(grps), grps = grps), by = "grps") # tip labels are `lineageid`s, not the species id, i.e. `grp`
      times = times %>% filter(lineageid %in% species$tip.label) %>% as.data.frame
      rownames(times) = times$lineageid
      times = times %>% select(-lineageid, -grps)
      extantids = rawinds$lineageid[rawinds$lineage==lineage & rawinds$time==max(times$FAD)] #FIXME! ?
      extantseqs = linseqs[dimnames(linseqs)[[1]] %in% extantids,]
      extanttree = gettree(extantseqs)
      extant = mksptree(extanttree, inferspecies(extanttree, spboundary))
      times = abs(times - 1000000) # fixed subtraction for comparability
      if (nrow(times) > 1 & length(species$tip.labels) >= minimumtips) {
        timed = timePaleoPhy(species, times, vartime=499, type="basic") ## default is "basic". "mbl" increases zero-length branches.
      } else {
        timed = times
      }
      list(tree=tre, species=species, timed=timed, extant=extant)
    }
  }
  names(allphylos) = unique(seqlins[seqlins %in% founderlins])
  allphylos[!sapply(allphylos, is.null)]
}

gettimedspp = function(phylos, inds) {
  timeddiv = foreach(i = 1:length(phylos)) %dopar% {
    steplength = inds %>% filter(lineage == names(phylos[1])) %>% select(time) %>% unlist %>% sort %>% unique %>% diff %>% min
    if (names(phylos[[i]]$timed)[1] != "FAD") {
      as_tibble(phyloDiv(phylos[[i]]$timed, int.length = steplength, plot = FALSE))
    } else {
      tibble(int.start = phylos[[i]]$timed$FAD, int.end = phylos[[i]]$timed$LAD, int.div = 1)
    }
  }
  names(timeddiv) = names(phylos)
  timeddiv
}

plot_phylos = function(allphylos, rawinds, basename = "all_timed_trees", minimumtips = 3, spboundary = 0.05){
    pdf(paste0(basename, minimumtips, "mintips", "-", spboundary, "spbnd", ".pdf"))
    for(i in 1:length(allphylos)) {
      if (names(phylos[[i]]$timed)[1] != "FAD") {
        phyloDiv(allphylos[[i]]$timed)
        linkage = rawinds %>% filter(lineage == names(allphylos[i])) %>% select(lnkgunits, ngenes) %>% unique %>%
          mutate(linkage = ngenes/lnkgunits) %>% select(linkage)
        title(main=paste(names(allphylos[i]), linkage[1]))
        if (!is.null(allphylos[[i]]$extant)) plot(allphylos[[i]]$extant)
      }
    }
    dev.off()
}

gettimemaxspp = function(timedspp, inds, filtermonospp = FALSE) {
  timemaxspp = tibble(
    lineage = names(timedspp),
    maxspp = sapply(timedspp, function(x) max(x$int.div)),
    timetomaxspp = sapply(timedspp, function(x) ifelse(max(x$int.div) > 1,
                                                       max(x$int.start) - x$int.start[which.max(x$int.div)], ## Times are reverse: present is 0
                                                       NA)),
    )
  timemaxspp = inds %>% filter(lineage %in% names(timedspp)) %>% group_by(lineage) %>%
    select_if(is.numeric) %>% summarize_all(mean) %>%
    select(lineage, lnkgunits, ngenes) %>% mutate(linkage = ngenes / lnkgunits) %>%
    left_join(timemaxspp, by = "lineage")
  if (filtermonospp == TRUE) {
    timemaxspp %>% filter(maxspp > 1)
  } else {
    timemaxspp
  }
}

getmaxspp = function(inds, timedspp) {
  colids = inds %>% filter(time == 0) %>% select(lineageid) %>% unlist
  founderlins = inds %>% filter(!(lineageid %in% colids)) %>% select(lineage) %>% unique %>% unlist
  maxspp = inds %>% filter(lineage %in% founderlins) %>% group_by(lineage, lnkgunits) %>%
    filter(time == max(time) | time == min(time)) %>% mutate(Phase = ifelse(time == max(time), "terminal", "initial")) %>% select(-(time:originid)) %>%
    group_by(lineage, lnkgunits, Phase) %>%  select(-new, -contains("adaptation"), -ngenes, -compat) %>% select_if(is.numeric) %>%
    summarize_all(mean) %>% right_join(gettimemaxspp(timedspp, inds, FALSE), by = c("lineage", "lnkgunits")) %>%
    mutate(`Category/phase` = paste(ifelse(maxspp > 1, "diverged", "monospecific"), Phase), diverged = ifelse(maxspp > 1, 1, 0)) %>%
    ungroup() %>% mutate_at(vars(repsize, seedsize), function(x) log(x + 1))
  maxspp
}

#+END_SRC

*** aggregate data

**** Using custom functions and parallelisation to prepare data structure

#+BEGIN_SRC R
setwd("/gaia5/storage/ecomod/ludwig/hpc/islspecmod/examples/islandradiation/")

full.inds = read_indfiles(path = "../../2019-10-29_islsim_", pattern = "full*/inds*", suffix = ".tsv")
none.inds = read_indfiles("../../2019-10-29_islsim_", "none*/inds*", ".tsv")
full.seqs = read_seqfiles(path = "../../2019-10-29_islsim_", pattern = "full*/", suffix = "*compats.fa")
none.seqs = read_seqfiles("../../2019-10-29_islsim_", "none*/", "*compats.fa")
rand.inds = read_indfiles("../../2020-02-*_islsimconfig", "*/inds*", ".tsv")
rand.seqs = read_seqfiles("../../2020-02-*_islsimconfig", "*/", "*.fa")

full.phylos = mkphylos(full.seqs, full.inds, spboundary = "actual")
none.phylos = mkphylos(none.seqs, none.inds, spboundary = "actual")

full.timedspp = gettimedspp(full.phylos, full.inds)
none.timedspp = gettimedspp(none.phylos, none.inds)

rand.phylos = mkphylos(rand.seqs, rand.inds, spboundary = "actual")
rand.timedspp = gettimedspp(rand.phylos, rand.inds)

rand.maxspp = getmaxspp(rand.inds, rand.timedspp)
none.maxspp = getmaxspp(none.inds, none.timedspp)
full.maxspp = getmaxspp(full.inds, full.timedspp)

#+END_SRC

**** Plot stuff
#+BEGIN_SRC R
rtp = bind_rows(none.maxspp) %>% gather("trait", "value", dispmean:linkage, -replicate) %>% mutate_at(vars(timetomaxspp), log10) %>%
  gather("response", "number", maxspp:timetomaxspp) %>%
  ggplot(aes(value, number, color = Phase)) + geom_point() + facet_grid(response ~ trait, scales="free") + theme_bw()
ggsave("pairs_none_maxspp_cols.pdf", rtp, width = 16, height = 4)
##cor(bind_rows(full.maxspp[, -1], none.maxspp[, -1]))
##cor(rand.maxspp[, -1])

##pdf("corgenspp.pdf", width = 20, height = 20)
##pairs(bind_rows(full.maxspp[, -1], none.maxspp[, -1]))
##pairs(rand.maxspp[, -1])
##dev.off()

rlmsp = rand.maxspp %>% filter(diverged == 1, Phase == "terminal") %>% select(reptol, linkage, maxspp) %>%
  ggplot(aes(reptol, maxspp, color = linkage)) + geom_point() + scale_color_viridis_c()
ggsave("reptol_linkage_maxspp_rand.pdf", rlmsp)


plot_phylos(full.phylos, full.inds, "full_timed_trees")
plot_phylos(none.phylos, none.inds, "none_timed_trees")
plot_phylos(rand.phylos, rand.inds, "rand_timed_trees")

#+END_SRC
**** Traits over time

#+BEGIN_SRC R
ttp = rand.inds %>% filter(!(lineageid %in% colids)) %>%
  mutate(linkage = ngenes/lnkgunits) %>%
  select(time, lineage, linkage, lnkgunits, ngenes, reptol, selfing, seedsize,
         repsize, dispmean, dispshape, prectol, temptol) %>%
  mutate_at(vars(repsize, seedsize), function(x) log(x + 1)) %>%
  group_by(time, lineage) %>% summarize_all(mean) %>%
  gather(linkage:temptol, key = Trait, value = `Trait value`) %>%
  ggplot(aes(time, `Trait value`, color = lineage)) +
  geom_line() + facet_wrap(. ~ Trait, scales="free")
ggsave("traits_time_all.pdf", ttp, height = 6, width = 12)
#+END_SRC

**** Traits distribution

#+BEGIN_SRC R
tdp = full.maxspp %>% #mutate_at(vars(dispmean:linkage, -replicate), function(x) scale(x, center = FALSE)) %>%
  group_by(`Category/phase`, lineage) %>%
  gather(dispmean:temptol, ngenes:linkage, key = Trait, value = `Trait value`) %>%
  ggplot(aes(`Category/phase`, `Trait value`, fill = `Category/phase`)) +
  geom_violin() + geom_boxplot(width = 0.3) + facet_wrap(. ~ Trait, scales="free") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_viridis_d()
ggsave("traits_distribution_full.pdf", tdp, height = 8, width = 12)
#+END_SRC

**** PCA

#+BEGIN_SRC R
endpca = prcomp(rand.maxspp[,-c(1:4,15,18:21)], scale=T)
endpcaviz = fviz_pca_biplot(endpca, geom.ind="point", fill.ind=rand.maxspp$`Category/phase`,
                            pointsize=1, pointshape=21, addEllipses = TRUE) + #, ellipse.alpha=0.1, ellipse.type = "convex") +
    theme_bw() + scale_fill_viridis_d("Divergence") + scale_colour_viridis_d("Divergence")
ggsave("pca_maintraits_all.pdf", endpcaviz, width=6, height=4)
pdf("pca_maintraits_eigen.pdf")
corrplot(endpca$rotation)
dev.off()
## nice clustering with PCA was with final trait syndrome!

endpca = prcomp(none.maxspp[,-c(1:4,15,17:21)] %>% filter_all(all_vars(!is.na(.))), scale=T)
endpcaviz = fviz_pca_biplot(endpca, geom.ind="point", fill.ind=none.maxspp[,-c(1:4,15,17:19,21)] %>% filter_all(all_vars(!is.na(.))) %>% select(`Category/phase`) %>% unlist,
                            pointsize=1, pointshape=21, addEllipses = TRUE) + #, ellipse.alpha=0.1, ellipse.type = "convex") +
    theme_bw() + scale_fill_viridis_d("Divergence") + scale_colour_viridis_d("Divergence")
ggsave("pca_maintraits_none.pdf", endpcaviz, width=6, height=4)
pdf("pca_maintraits_eigen.pdf")
corrplot(endpca$rotation)
dev.off()

#+END_SRC

**** Lineage-rank plots

#+BEGIN_SRC R
lrp = rand.maxspp %>% ungroup %>% filter(Phase == "initial") %>% ggplot(aes(reorder(lineage, -maxspp), maxspp)) +
  geom_bar(stat = "identity") + xlab("Lineage") + ylab("Maximum number of species") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggsave("lineage_rank.pdf", lrp)
#+END_SRC

**** Clustering

#+BEGIN_SRC R
rand.kmeans = rand.maxspp %>% filter(Phase == "initial") %>% select(dispmean:linkage, diverged, -replicate) %>% kmeans(centers = 3, nstart = 25)
clp = fviz_cluster(rand.kmeans, data = rand.maxspp %>% select(dispmean:linkage, diverged, -replicate))
ggsave("kmeans.pdf", clp)
#+END_SRC

**** models
#+BEGIN_SRC R
## lmem not usable because each lineage exclusive to the scenarios

anova(glmer(diverged ~ dispshape + repsize + reptol + prectol + temptol +
              selfing + seedsize + ngenes + (1|replicate), family = binomial, data = bind_rows(rand.maxspp#, none.maxspp, full.maxspp
                                                                                               ) %>% filter(Phase == "initial") %>%
                                                                                mutate(lineage = as.factor(lineage)) %>%
                                                                                mutate_at(vars(dispmean:linkage, -replicate), scale)))
anova(lm(maxspp ~ dispmean + dispshape + repsize + reptol + linkage + prectol + temptol +
             selfing + seedsize + ngenes, data = bind_rows(rand.maxspp#, none.maxspp, full.maxspp
                                                                                           ) %>% ungroup %>% mutate(lineage = as.factor(lineage))))
anova(lm(maxspp ~ temptol * prectol + reptol +
             selfing + ngenes + linkage, data = bind_rows(rand.maxspp#, none.maxspp, full.maxspp
                                                                                           ) %>% ungroup %>% mutate(lineage = as.factor(lineage))))
anova(lm(timetomaxspp ~ dispmean + dispshape + precopt + prectol + repsize + reptol + linkage +
             selfing + seedsize + tempopt + temptol + ngenes, data = bind_rows(rand.maxspp#, none.maxspp, full.maxspp
                                                                                           )))
aov(lm(timetomaxspp ~ dispshape + prectol + repsize + linkage +
             selfing + seedsize + tempopt + temptol + ngenes, data = bind_rows(rand.maxspp#, none.maxspp, full.maxspp
                                                                                           )))
summary(lm(maxspp ~ timetomaxspp + linkage + ngenes, data = bind_rows(rand.maxspp, none.maxspp, full.maxspp)))
summary(lm(timetomaxspp ~ maxspp + linkage + ngenes, data = bind_rows(rand.maxspp, none.maxspp, full.maxspp)))

#+END_SRC
**** check normality

#+BEGIN_SRC R

## some traits increase in normality with log(x+1) transformation
## TODO: do qqplots for skewness etc. and identify which traits need transformation!

pdf("qqplots.pdf")
bind_rows(rand.maxspp, none.maxspp, full.maxspp) %>% ungroup %>% select(dispmean, dispshape, precopt, prectol,
                                   repsize, reptol, linkage, selfing, seedsize, tempopt, temptol,
                                   ngenes) %>% #mutate_all(function(x) log(x+1)) %>%
  as.list %>% lapply(qqnorm)
dev.off()

rand.maxspp %>% ungroup %>% select(maxspp, timetomaxspp, dispmean, dispshape, precopt, prectol,
                                   repsize, reptol, linkage, selfing, seedsize, tempopt, temptol,
                                   ngenes) %>% mutate_all(function(x) log(x+1)) %>% as.list %>%
                              lapply(shapiro.test)

#+END_SRC
